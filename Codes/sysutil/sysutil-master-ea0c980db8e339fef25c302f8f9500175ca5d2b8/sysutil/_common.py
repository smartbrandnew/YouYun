# coding: utf-8"""Common objects shared by __init__.py and _ps*.py modules."""# Note: this module is imported by setup.py so it should not import# psutil or third-party modules.from __future__ import divisionimport osimport sysimport inspectimport localeimport subprocessfrom functools import wrapsfrom collections import namedtuple__all__ = [    # constants    'LINUX',    'POSIX',    'AIX',    'WINDOWS',    'DARWIN',    'ENCODING',    'ENCODING_ERRS',    # named tuples    # utility functions    'add_unit',    'get_with_general_unit',    'get_with_bytes_unit']# ===================================================================# --- Program constants# ===================================================================# ===================================================================# --- OS constants# ===================================================================POSIX = os.name == "posix"WINDOWS = os.name == "nt"LINUX = sys.platform.startswith("linux")AIX = sys.platform.startswith("aix")DARWIN = sys.platform.startswith('darwin')ENCODING = locale.getpreferredencoding()# ===================================================================# --- namedtuples# ===================================================================# --- for system functions# sysutil.disk_info()sdiskpart = namedtuple('sdiskpart', ['device', 'mountpoint', 'total'])# sysutil.cpu_info()scpuinfo = namedtuple('scpuinfo', [    'brand', 'frequency', 'family', 'vendor_id', 'stepping', 'cache_size',    'model'])# sysutil.network_info()snetworkinfo = namedtuple('snetworkinfo',                          ['name', 'mac', 'ipv4', 'ipv6', 'netmask'])# ===================================================================# --- Exceptions# ===================================================================class ExecuteError(Exception):    def __init__(self, cmd, reason=''):        super(ExecuteError,              self).__init__('When executing cmd: {!r} occurs an error!\n'                             'Reason: {}.'.format(cmd, reason))# ===================================================================# --- utils# ===================================================================def cache(func):    caches = {}    @wraps(func)    def wrap(*args):        if args not in caches:            caches[args] = func(*args)        return caches[args]    return wrapdef execute(cmd):    p = subprocess.Popen(        cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    stdout, stderr = p.communicate()    if p.poll() == 0:        return stdout    else:        raise ExecuteError(cmd, reason=stderr)symbols = ('B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB')def get_with_general_unit(size, unit):    return u'{} {}'.format(size, unit)def get_with_bytes_unit(bytes,                        unit=None,                        precision=1,                        comma=False,                        multiple=1024):    bytes, unit = convert_bytes(bytes, unit, multiple)    values = (('%.' + str(precision) + 'f') % bytes).split('.')    if comma:        values[0] = '{:,}'.format(int(values[0]))    return u'{} {}'.format('.'.join(values), unit)def convert_bytes(bytes, unit=None, multiple=1024):    step = 0    if not unit:        while bytes >= multiple and step < len(symbols) - 1:            bytes /= multiple            step += 1        unit = symbols[step]    else:  # convert to specific unit        index_of_unit = symbols.index(unit)        while len(symbols) - 1 > step and index_of_unit != step:            bytes /= multiple            step += 1    return bytes, unitdef _get_kwargs(func, *func_args, **func_kwargs):    kwargs = func_kwargs.copy()    argspect = inspect.getargspec(func)    for i, arg in enumerate(func_args):        kwargs[argspect.args[i]] = arg    return kwargsdef add_unit(unit=None, precision=0, comma=False, multiple=1024):    """Add unit wrapper.    If not unit or unit in ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB',    'YB'], automatically convert value to suitable value with unit.    value's unit wile be regarded as 'B'.    For example:        unit=None, precision=0, 1111 will convert to '1 KB'        unit='MB', precision=3, 1111 will convert to '0.001 MB'    Else, return value with supplied unit.    """    def _add_unit(func):        def _wrapper(*args, **kwargs):            size = func(*args, **kwargs)            kwargs = _get_kwargs(func, *args, **kwargs)            add_unit_ = kwargs.get('add_unit')            if not add_unit_:                return size            if unit in symbols or not unit:                size = get_with_bytes_unit(                    bytes=size,                    unit=unit,                    precision=precision,                    comma=comma,                    multiple=multiple)            else:                size = get_with_general_unit(size, unit)            return size        return _wrapper    return _add_unitdef to_hz_string(ticks):    # Convert to string    ticks = '{0}'.format(ticks)    # Add decimal if missing    if '.' not in ticks:        ticks = '{0}.0'.format(ticks)    # Remove trailing zeros    ticks = ticks.rstrip('0')    # Add one trailing zero for empty right side    if ticks.endswith('.'):        ticks = '{0}0'.format(ticks)    return ticks