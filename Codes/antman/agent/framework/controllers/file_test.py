import osimport loggingimport tempfilefrom mock import patchfrom tornado.web import Application, RequestHandlerfrom tornado.testing import AsyncHTTPTestCasefrom framework import settingsfrom framework.config import configfrom framework.controllers.file import FileHandlerfrom framework.ioloop import get_io_looplogger = logging.getLogger('default')class UpstreamFileHandler(RequestHandler):    def get(self, filename):        file_path = os.path.join(settings.REPO_DIR, settings.REPO_ANT_SPACENAME,                                 filename)        lock_path = file_path + os.path.extsep + 'lock'        if not os.path.exists(lock_path):            logger.error('Lock file does not exist: %s', lock_path)            self.send_error(400)            return        self.write(filename)class FileHandlerTest(AsyncHTTPTestCase):    def setUp(self):        super(FileHandlerTest, self).setUp()        self._origin_repo_dir = settings.REPO_DIR        settings.REPO_DIR = tempfile.mkdtemp()    def tearDown(self):        super(FileHandlerTest, self).tearDown()        settings.REPO_DIR = self._origin_repo_dir    def get_new_ioloop(self):        return get_io_loop()    def get_app(self):        return Application([(r'/file', FileHandler),                            (r'/upstream/file/(\S+)', UpstreamFileHandler)])    def test_file_cache_hit(self):        with patch('framework.controllers.file.nfs.exists') as mock:            mock.return_value = True            response = self.fetch('/file?filename=test.tgz')            self.assertEqual(response.code, 200)            self.assertEqual(response.body,                             os.path.join(settings.REPO_DIR,                                          settings.REPO_ANT_SPACENAME,                                          'test.tgz'))    def test_file_cache_missed_with_lock_file_existed(self):        with patch('framework.controllers.file.nfs.exists') as mock:            mock.side_effect = [                ########################################                # [method "get"]                       #                #   not nfs.exists(self.space_dir)     #                ########################################                False,                ########################################                # [method "makedirs"]                  #                #   nfs.exists(name)                   #                ########################################                True,                ########################################                # [method "try_to_return_file_cache"]  #                #   nfs.exists(self.filepath)          #                ########################################                False,                ########################################                # [method "get"]                       #                #   nfs.exists(self.lock_path)         #                ########################################                True,                ########################################                # [method "waiting_for_file_complete"] #                #   not nfs.exists(self.lock_path)     #                ########################################                False,                ########################################                # [method "waiting_for_file_complete"] #                #   nfs.exists(self.filepath)          #                ########################################                True            ]            with patch.dict(config, {'file_service_lock_watch_interval': 0}):                response = self.fetch(                    '/file?filename=test.tgz&auth_token=public')                self.assertEqual(response.body,                                 os.path.join(settings.REPO_DIR,                                              settings.REPO_ANT_SPACENAME,                                              'test.tgz'))    def test_file_cache_missed_with_lock_file_existed_then_timeout(self):        with patch('framework.controllers.file.nfs.exists') as mock:            mock.side_effect = [                ########################################                # [method "get"]                       #                #   not nfs.exists(self.space_dir)     #                ########################################                False,                ########################################                # [method "makedirs"]                  #                #   nfs.exists(name)                   #                ########################################                True,                ########################################                # [method "try_to_return_file_cache"]  #                #   nfs.exists(self.filepath)          #                ########################################                False,                ########################################                # [method "get"]                       #                #   nfs.exists(self.lock_path)         #                ########################################                True,                ########################################                # [method "waiting_for_file_complete"] #                #   not nfs.exists(self.lock_path)     #                ########################################                True,            ]            with patch.dict(config, {                    'file_service_lock_watch_interval': 0.02,                    'file_service_request_timeout': 0.01            }):                response = self.fetch('/file?filename=test.tgz')                self.assertEqual(response.code, 504)    def test_file_cache_missed_with_lock_file_not_existed(self):        with patch('framework.controllers.file.nfs.exists') as mock:            mock.side_effect = [                ########################################                # [method "get"]                       #                #   not nfs.exists(self.space_dir)     #                ########################################                False,                ########################################                # [method "makedirs"]                  #                #   nfs.exists(name)                   #                ########################################                False,                ########################################                # [method "try_to_return_file_cache"]  #                #   nfs.exists(self.filepath)          #                ########################################                False,                ########################################                # [method "get"]                       #                #   nfs.exists(self.lock_path)         #                ########################################                False,                ########################################                # [method "rename" module "nfs"]       #                #   exists(dst)                        #                ########################################                False,                ########################################                # [method "close_file_resource" ]      #                #   nfs.exists(self.lock_path)         #                ########################################                False,            ]            with patch.dict(config, {'upstream': self.get_url('/upstream')}):                response = self.fetch('/file?filename=test.tgz')                self.assertEqual(response.code, 200)                file_path = os.path.join(                    settings.REPO_DIR, settings.REPO_ANT_SPACENAME, 'test.tgz')                lock_path = file_path + os.path.extsep + 'lock'                self.assertEqual(response.body, file_path)                with open(file_path) as f:                    s = f.read()                    self.assertEqual(s, 'test.tgz')                self.assertFalse(os.path.exists(lock_path))